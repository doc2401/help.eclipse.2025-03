<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>VIATRA CPS Demonstrator</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body class="article">
<div id="header">
<h1>VIATRA CPS Demonstrator</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_overview">Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The CPS Demonstrator is specified to cover a usual workflow in Model-driven Engineering, where a system is (1) first described in a <strong>source domain model</strong>, then (2) automated <strong>model-to-model transformations</strong> are used to derive a <strong>target domain model</strong>. Finally, (3) <strong>model-to-text transformation</strong> is performed to generate code from the target domain. In addition, a <strong>model generator</strong> that can automatically create source domain models can support the correctness <strong>testing</strong> and <strong>performance evaluation</strong> of the components.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/cps/overview.png" alt="CPS Demonstrator overview">
</div>
<div class="title">Figure 1. CPS Demonstrator overview</div>
</div>
<div class="paragraph">
<p>In this example, the source domain (CPS) represents a <strong>Cyber-Physical System</strong> with applications with dynamic behaviour allocated to connected hosts. The target domain (Deployment) represents the system <strong>deployment</strong> configuration, with stateful applications contained by hosts. Instance models of the two domains are connected by a traceability model for maintaining <strong>correspondence</strong> between related elements. These domains are modelled in <strong>Ecore</strong> and instance models are handled using the code generated by EMF.</p>
</div>
<div class="paragraph">
<p>For more information about the domains, consult section <a href="#_domains">Domains</a>.</p>
</div>
<div class="sect2">
<h3 id="_cps_to_deployment_transformation">CPS-to-Deployment Transformation</h3>
<div class="paragraph">
<p>The <a href="#_cps_to_deployment_transformation">CPS-to-Deployment</a> model-to-model transformation derives a deployment model from a CPS model and also creates the correspondence in a traceability model. In addition, model-to-model transformations should be able <strong>synchronize changes</strong> in the CPS model to the deployment model and the traceability model. <a href="#_transformation_implementations">Alternative transformation methods</a> can be implemented, with some variant offering only <strong>batch execution</strong> functionalities (recreating the deployment and traceability models every time), while other alternatives are capable of <strong>incremental execution</strong>, where only changes are propagated.</p>
</div>
<div class="paragraph">
<p>The transformation creates deployment hosts for each CPS host instance, then creates deployment applications in these hosts for all application instances allocated to the corresponding CPS host. Next, the state machine of the application type for each mapped application instance is mapped to a deployment behaviour of the deployment application. This includes creating states and transitions as well, although the two metamodels represent state machines and behaviours in a slightly different way. Finally, transition actions are processed and trigger references are created between behaviour transitions if the model structure and the actions are set up in a given way (<a href="#_rules">Step 6. in the specification</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_deployment_code_generation">Deployment Code Generation</h3>
<div class="paragraph">
<p>The <a href="#_code_generator_distributed_realization_xtend_templates">Deployment Code Generation</a> model-to-text transformation takes a deployment model and outputs <strong>Java code</strong> that can simulate the dynamic behaviour of the system. Each host is executed on separate threads by <strong>host runners</strong>, while inter-host triggers are implemented by message passing through a simple <strong>communication network</strong> object. Once again, based on a single specification, multiple model-to-text alternatives can be provided, with incremental approaches re-generating only parts of the source code that are affected by deployment model changes. These changes are collected using a <a href="#_deployment_change_monitor">deployment change monitor</a>, which uses VIATRA Query to <strong>aggregate</strong> low level deployment model <strong>modifications</strong> and <strong>provide deltas</strong> that specify the changed elements (hosts, applications, behaviours).</p>
</div>
<div class="paragraph">
<p>The code generator creates source code fragments from elements of the deployment model, these include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Deployment</strong> for creating the top level configuration that sets up host objects</p>
</li>
<li>
<p><strong>Host</strong> for creating the code that sets the applications for a host</p>
</li>
<li>
<p><strong>Application</strong> for creating code that sets up an application, with a current state</p>
</li>
<li>
<p><strong>Behavior</strong> for creating code for a deployment behaviour including states and transitions (with triggers).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The generated code uses base classes that contain model-independent code and some common classes that are used for the execution (e.g. communication network).</p>
</div>
</div>
<div class="sect2">
<h3 id="_further_information">Further information</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_incremental_viewers">VIATRA Viewers example</a></p>
</li>
<li>
<p><a href="#_live_validation">Model Validation example</a></p>
</li>
<li>
<p><a href="#_example_model_generation">Generating example models</a></p>
</li>
<li>
<p>A <a href="#_model_generator">CPS Model Generator</a> is available to create arbitrary sized CPS model instances</p>
</li>
<li>
<p>The transformation components are tested with <strong>unit tests</strong> and <strong>integration tests</strong></p>
</li>
<li>
<p><a href="CPS-to-Deployment-Unit-Tests.html">Unit tests for the M2M transformation</a></p>
</li>
<li>
<p>The CPS demonstrator is also used as a performance benchmark for VIATRA, see see the <a href="https://github.com/viatra/viatra-cps-benchmark/wiki">VIATRA CPS Benchmark</a> wiki for details.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_domains">Domains</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_cyber_physical_system">Cyber Physical System</h3>
<div class="paragraph">
<p>The CPS domain specifies application and host types and their instances, requests and requirements on applications and resource requirements of applications towards hosts. Application types have a state machine that describes their behavior through states and transitions. Finally, application instances can be allocated to host instances that can communicate with each other.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/cps/cps_ecore.png" alt="Cyber Physical System model Ecore diagram">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Host instances have a unique node IP address.</p>
</li>
<li>
<p>Application instances have a unique identifier.</p>
</li>
<li>
<p>State machines can define an initial state.</p>
</li>
<li>
<p>Transitions may specify an action for sending or waiting for a signal. A signal can be sent by providing an application type (with its ID) and a signal identifier, while waiting for a signal is done by specifying its identifier.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_deployment">Deployment</h3>
<div class="paragraph">
<p>In the deployment model, host instances contain the applications that are running on them, while each application has a behavior with states and transitions. The behavior has a current state and transitions may trigger other transitions when the triggered transition is waiting for the signal they are sending and the application type is correct.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/cps/deployment_ecore.png" alt="Deployment model Ecore diagram">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_traceability">Traceability</h3>
<div class="paragraph">
<p>The traceability model describes the correspondence between a CPS and a deployment model. The traceability is stored in a set of traces that refer to zero, one or multiple CPS and deployment elements.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/cps/traceability_ecore.png" alt="Traceability model Ecore diagram">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cps_to_deployment_transformation_2">CPS-to-Deployment Transformation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_specification">Specification</h3>
<div class="paragraph">
<p>This specification describes what is expected from any <a href="#_transformation_implementations">CPS-to-Deployment implementation variant</a>.</p>
</div>
<div class="sect3">
<h4 id="_input">Input</h4>
<div class="ulist">
<ul>
<li>
<p><a href="#_cyber_physical_system">Cyber Physical System</a> instance model that satisfies the validation rules defined on the <a href="#_live_validation">Live Validation</a> page.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_output">Output</h4>
<div class="ulist">
<ul>
<li>
<p><a href="#_deployment">Deployment</a> instance model</p>
</li>
<li>
<p><a href="#_traceability">Traceability</a> instance model between the CPS and Deployment instance models</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_rules">Rules</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Host mapping:</strong> All host instances in the CPS are transformed into deployment hosts.</p>
<div class="ulist">
<ul>
<li>
<p>The <em>IP address</em> of the host instance is copied to the deployment model.</p>
</li>
<li>
<p><strong>Traceability:</strong> A trace is created between each host instance and related deployment host (<code>1-to-1</code>).</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Application mapping:</strong> All application instances allocated to a host instances in the CPS are transformed into deployment applications.</p>
<div class="ulist">
<ul>
<li>
<p>The <em>identifier</em> of the application instance is copied to the deployment model.</p>
</li>
<li>
<p><strong>Traceability:</strong> A trace is created between each application instance and related deployment application (<code>1-to-1</code>).</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>State machine mapping:</strong> All deployment applications will contain a deployment behavior transformed from the state machine of their application type.</p>
<div class="ulist">
<ul>
<li>
<p>The <em>identifier</em> of the state machine is copied to the description of the deployment behavior.</p>
</li>
<li>
<p><strong>Traceability:</strong> A trace is created for each state machine and it refers to all deployment behaviors mapped from that state machine (<code>1-to-n</code>).</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>State mapping:</strong> Each state of state machines are transformed as behavior states into all deployment behaviors for the given state machine.</p>
<div class="ulist">
<ul>
<li>
<p>The <em>identifier</em> of the state is copied to the description of the behavior state.</p>
</li>
<li>
<p><strong>Traceability:</strong> A trace is created for each state and it refers to all behavior states mapped from that state (<code>1-to-n</code>).</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Transition mapping:</strong> Each transition of state machines are transformed as behavior transitions into all deployment behaviors for the given state machine.</p>
<div class="ulist">
<ul>
<li>
<p>The <em>identifier</em> of the transition is copied to the description of the behavior transition.</p>
</li>
<li>
<p>The behavior transition is added to the <em>outgoing transitions</em> of the behavior state mapped from the state containing the transition to the given deployment behavior.</p>
</li>
<li>
<p>The <em>to</em> reference of the behavior transition is set to the behavior state mapped from the target state of the transition to the given deployment behavior.</p>
</li>
<li>
<p><strong>Traceability:</strong> A trace is created for each transition and it refers to all behavior transition mapped from that transition (<code>1-to-n</code>).</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Action mapping:</strong> The actions of transitions are transformed into <em>trigger</em> references between behavior transitions.</p>
<div class="ulist">
<ul>
<li>
<p>A behavior transition <code>SBT</code> related to a CPS transition <code>STr</code> with action <code>sendSignal(appTypeId,signalId)</code> will trigger all behavior transitions <code>WBT</code> related to CPS transitions <code>WTr</code> with action <code>waitForSignal(signalId)</code>, if:</p>
<div class="ulist">
<ul>
<li>
<p>The identifier of the application type that contains the state machine of <code>WTr</code> is <code>appTypeId</code>.</p>
</li>
<li>
<p>The application instance related to the deployment application containing <code>SBT</code> is allocated to host instance <code>H1</code>.</p>
</li>
<li>
<p>The application instance related to the deployment application containing <code>WBT</code> is allocated to host instance <code>H2</code>.</p>
</li>
<li>
<p><code>H1</code> can communicate with <code>H2</code> transitively:</p>
<div class="ulist">
<ul>
<li>
<p><code>H1</code> and <code>H2</code> may be the same</p>
</li>
<li>
<p><code>H2</code> is included in the set of values of <code>communicatesWith</code> in <code>H1</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Traceability</strong>: No trace records are created for the created triggers.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_testing">Testing</h3>
<div class="paragraph">
<p>We provide <a href="CPS-to-Deployment-Unit-Tests.html">unit tests</a> that are defined based on this specification and can test the correctness of any transformation variant.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_transformation_implementations">Transformation Implementations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The VIATRA project has already provided multiple implementations for the demonstrator. These variants differ from each other in at least one characteristics to support comparison and evaluation. Characteristics include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>execution mode (batch or incremental)</p>
</li>
<li>
<p>used technologies (Xtend, VIATRA, other transformation tools)</p>
</li>
<li>
<p>model traversal vs. event-driven transformation</p>
</li>
<li>
<p>execution on partially transformed model</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These implementations will be created under the <a href="https://git.eclipse.org/c/viatra/org.eclipse.viatra.examples.git/tree/cps/transformations">transformations</a> folder in the repository and under the <code>org.eclipse.viatra.query.examples.cps.xfrom.m2m.&lt;id&gt;</code> namespace.</p>
</div>
<div class="sect2">
<h3 id="_batch">Batch</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Xtend (<code>id = batch.simple</code>, <a href="#_simple_and_optimized_xtend_batch_m2m_transformation">details</a>)</p>
</li>
<li>
<p>Xtend + VIATRA Query (<code>id = batch.eiq</code>, <a href="#_simple_xtend_and_query_m2m_transformation">details</a>)</p>
</li>
<li>
<p>VIATRA Batch API (<code>id = batch.viatra</code>, <a href="#_viatra_transformation_api_based_batch_m2m_transformation">details</a>)</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_incremental">Incremental</h3>
<div class="paragraph">
<p>For the incremental alternatives, a differentiating factor is the method to identify changes in the source model which must be synchronized to the target ("dirty flag")</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Direct notification (<code>id = incr.direct</code>)</p>
<div class="ulist">
<ul>
<li>
<p>dirty: EMF adapter/IQBase</p>
</li>
</ul>
</div>
</li>
<li>
<p>Explicit traceability (<code>id = incr.expl</code>)</p>
<div class="ulist">
<ul>
<li>
<p>dirty: traceability model state</p>
</li>
<li>
<p>Details <a href="#_explicit_traceability_m2m_transformation">here</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Query result traceability (<code>id = incr.qrt</code>)</p>
<div class="ulist">
<ul>
<li>
<p>dirty: query result bookmarking, traceability saved in deltamonitor</p>
</li>
<li>
<p>Details <a href="#_query_result_traceability_m2m_transformation">here</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Partial batch transformation (<code>id = incr.aggr</code>)</p>
<div class="ulist">
<ul>
<li>
<p>dirty: consider query results as notifications/events, low level change aggregation (transform bigger parts)</p>
</li>
<li>
<p>advanced: notifications independent of source model, transformation may run in background</p>
</li>
<li>
<p>Details <a href="#_partial_batch_m2m_transformation">here</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Change-driven transformations  (<code>id = incr.cdt</code>)</p>
<div class="ulist">
<ul>
<li>
<p>dirty: EVM activation life-cycle</p>
</li>
</ul>
</div>
</li>
<li>
<p>VIATRA EMF-based <a href="transformations.html">transformation API</a>  (<code>id = incr.viatra</code>)</p>
<div class="ulist">
<ul>
<li>
<p>Details <a href="#_viatra_transformation_api_based_qrt_m2m_transformation">here</a></p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_summary">Summary</h3>
<div class="paragraph">
<p>We currently implemented the above mentioned different variants (if you know VIATRA Query well you may argue that the LS based should be considered as a separate one :-) ) for this transformation and in the future might add some additional ones built on our technology stack. However, we would like to invite variants using other transformation tools. Since the demonstrator is open source, this may involve users of other tools or even submitted as a case to the <a href="http://www.transformation-tool-contest.eu/">Transformation Tool Contest</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_simple_and_optimized_xtend_batch_m2m_transformation">Simple and Optimized Xtend Batch M2M Transformation</h3>
<div class="sect3">
<h4 id="_introduction">Introduction</h4>
<div class="paragraph">
<p>The basic idea for the batch transformations - both for the simple and optimized versions - is to programmatically traverse the model that is to be transformed and apply all the transformation rules where they are applicable. Model traversal is done by using only basic language concepts and without using any advanced technologies or complex frameworks.</p>
</div>
</div>
<div class="sect3">
<h4 id="_how_does_it_work">How does it work</h4>
<div class="paragraph">
<p>The basic concept of this batched transformation is to transform a CPS model to a complete deployment model. This solution doesn&#8217;t support incremental transformation, only the whole model can be transformed, and it uses the following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It receives a root element for a mapping model which connects a CPS model root and a Deployment model root. The initialization step is to clear all traces from the mapping model and to delete all deployment hosts, if there is any.</p>
</li>
<li>
<p>Iterates over every HostInstance in the CPS model using foreach and transforms each of them to DeploymentHosts. In every iteration DeploymentApplications are also created from ApplicationInstances (see next step) and added to the hosts' containments which are allocated to the host being processed.</p>
</li>
<li>
<p>For each ApplicationInstance a DeploymentApplication is created. If the ApplicationType of the ApplicationInstance refers to a StateMachine, a DeploymentBehavior is also added for the ApplicationInstance (see next step)</p>
</li>
<li>
<p>The States of the StateMachine referred by the ApplicationType are transformed to BehaviorStates. For each State, the Transitions are transformed to BehaviorTransitions (see next step)</p>
</li>
<li>
<p>For each Transition between States of a StateMachine a BehaviorTransition is created connecting the corresponding BehaviorStates.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_handling_of_1_to_n_mappings">Handling of 1-to-n mappings</h4>
<div class="paragraph">
<p>Mappings with 1-to-n multiplicity are created in the following cases</p>
</div>
<div class="ulist">
<ul>
<li>
<p>StateMachine - DeploymentBehavior</p>
</li>
<li>
<p>State - BehaviorState</p>
</li>
<li>
<p>Transition - BehaviorTransition</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This means that a trace is only created once for each of these CPS elements, and as the transformation advances the list of deployment elements of the trace might expand.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creation_of_triggers">Creation of triggers</h4>
<div class="paragraph">
<p>Triggers are created after all other model elements are created. First all mappings for Transitions in the CPS model are collected. In the next step all Transitions are selected which are sending a message (at this point we use that every transition can send/receive up to one message). When this is done all corresponding receiver Transitions are searched based on the action string. After this a trigger is created for each BehaviorTransition mapped to the sender Trace and each BehaviorTransition mapped to the receiver Traces if their container DeploymentHosts can communicate with each other.</p>
</div>
<div class="paragraph">
<p>To inspect DeploymentHost communication capability, their corresponding HostInstances are used: the communicatesWith relation is traversed using DFS. When the receiver HostInstances in the CPS model can be reached, the corresponding DeploymentHost is regarded as reachable.</p>
</div>
</div>
<div class="sect3">
<h4 id="_class_of_the_transformation_and_example">Class of the transformation and example</h4>
<div class="paragraph">
<p>The class for the transformation is an Xtend class named <code>CPS2DeploymentBatchTransformationSimple</code>. To apply the transformation, just instantiate the class with a traceability model pointing to the CPS and Deployment model roots and invoke the <code>execute</code> method :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// we assume there is an initialization row before like CPSToDeployment cps2dep = ...
xform = new CPS2DeploymentBatchTransformationSimple(cps2dep)
xform.execute</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_optimized_batch_m2m_transformation">Optimized batch M2M transformation</h4>
<div class="paragraph">
<p>In order to speed up the Xtend based variant we also developed a so called optimized version (<code>CPS2DeploymentBatchTransformationOptimized</code>). It is based on the simple batch transformation, however, includes the following optimizations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A caching mechanism that is to store the created traceability information for created model elements in map data structures (one map for both directions) to avoid traversal of traceability model. In case of BehaviorTransitions, the application type ID, action ID and HostInstance are also stored based on the CPS model for faster trigger creation.</p>
</li>
<li>
<p>Code restructuring for better loop execution</p>
</li>
<li>
<p>When creating triggers, the data for the receiver behavior transition are obtained in the outer for loop instead of the inner for loop.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This version can be executed using the following commands:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>xform = new CPS2DeploymentBatchTransformationOptimized(cps2dep)
xform.execute</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_summary_and_comparison">Summary and comparison</h4>
<div class="paragraph">
<p>These two batch transformation methods, compared to the other implemented transformation techniques, have proven to be the least time-effective. However, it can be said that the optimized version preformed the same transformation during half the time of the simple transformation. The memory consumption is not necessarily low, but it was not the bottleneck concerning the performance.</p>
</div>
<div class="paragraph">
<p>The introduced transformations are not taking changes into consideration, they always perform a complete traversal of the CPS model. This is the main reason for the bad performance results compared to the incremental transformations when there is a change in the CPS model, that needs to be propagated via a repeated, complete transformation to the Deployment model.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_simple_xtend_and_query_m2m_transformation">Simple Xtend and Query M2M transformation</h3>
<div class="sect3">
<h4 id="_introduction_2">Introduction</h4>
<div class="paragraph">
<p>The idea behind this transformation variant is similar in concept to the <a href="#_simple_and_optimized_xtend_batch_m2m_transformation">simple Xtend batch</a> variant. Traverse the model and transform the elements according to the specification. The main difference is the usage of VIATRA Query patterns in place of complex queries (e.g. finding send and wait signal pairs), making the transformation faster and more memory efficient.</p>
</div>
</div>
<div class="sect3">
<h4 id="_how_does_it_work_2">How does it work</h4>
<div class="paragraph">
<p>The transformation can be separated into 2 distinct steps. Building the deployment model itself and, wherever required, setting the relationships of the model elements.</p>
</div>
<div class="paragraph">
<p>To build the model, the transformation walks through the CPS model in the following hierarchy:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HostInstance</p>
<div class="ulist">
<ul>
<li>
<p>ApplicationInstance</p>
<div class="ulist">
<ul>
<li>
<p>StateMachine</p>
<div class="ulist">
<ul>
<li>
<p>State</p>
</li>
<li>
<p>Transition</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The transformation is described by the following steps.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The first step is to iterate through each HostInstance and create the DeploymentHost representing it, set its IP address and add it to the Deployment model.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>For each ApplicationInstance inside the HostInstance a DeploymentInstance is created, its id is set to be the same as the ApplicationInstance&#8217;s and is added to the proper DeploymentHost.</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>If the ApplicationInstance&#8217;s type has a StateMachine specified a DeploymentBehavior representing it is created,  its description is set and is added to the proper ApplicationInstance.</p>
<div class="olist upperalpha">
<ol class="upperalpha" type="A">
<li>
<p>For each State in the StateMachine a BehaviorState based on the original State is created, its description is set and is added to the proper DeploymentBehavior.</p>
</li>
<li>
<p>For each State&#8217;s each Transition a BehaviorTransition is created, its description is set and is added to both the proper DeploymentBehavior and as an outgoing transition of the BehaviorState. At this point using the Transition&#8217;s target state, the BehaviorTransition&#8217;s to reference can be set.</p>
</li>
<li>
<p>The DeploymentBehavior&#8217;s current state is set to the corresponding StateMachine&#8217;s initial state.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>At this point, the triggers are set as specified by the transformation. This is done via getting the Transition for each BehaviorTransition. If the Transition has a send action, the directly reachable hosts are checked for Transitions under the correct ApplicationType&#8217;s StateMachine, and if any are found, their BehaviorTransition counterparts are added.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Each time a new element of the deployment model is created, the traceability model gets modified as required.</p>
</div>
</div>
<div class="sect3">
<h4 id="_handling_of_1_to_n_mappings_2">Handling of 1-to-n mappings</h4>
<div class="paragraph">
<p>Since the transformation is done via traversing the CPS model hierarchy, the 1-to-n mappings are created automatically. The most important thing to consider is the nature of the traceability model. Since for example each State can have multiple corresponding BehaviorStates, when searching for a specific DeploymentApplication&#8217;s BehaviorState using the traceability model, the correct one should be filtered.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creation_of_triggers_2">Creation of triggers</h4>
<div class="paragraph">
<p>The creation of the triggers was mostly done leveraging the power of VIATRA Query.</p>
</div>
<div class="paragraph">
<p>The main pattern used is the one named "triggerPair". This pattern returns the BehaviorTransition for every Tansition with wait action corresponding to the specified Transition with send action.</p>
</div>
<div class="paragraph">
<p>The other important pattern is "communicatingAppInstances". This pattern searches for every ApplicationInstance pair allocated to hosts that can directly communicate with each other.</p>
</div>
</div>
<div class="sect3">
<h4 id="_class_of_the_transformation">Class of the transformation</h4>
<div class="paragraph">
<p>The implementation of the transformation can be found in the following class:
<code>CPS2DeploymentBatchTransformationEiq.xtend</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_summary_and_comparison_2">Summary and comparison</h4>
<div class="paragraph">
<p>This method of transformation proved to be the fastest of all alternatives, while being the most memory efficient of the transformation variants using VIATRA Query. This is mainly due to the fact that it is not required to build complex VIATRA Query patterns aimed at tracking changes in the model. This is also it&#8217;s main handicap since the transformation is not incremental, thus it needs to traverse the cps model and rebuild the traceability and deployment model to maintain consistency.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_viatra_transformation_api_based_batch_m2m_transformation">VIATRA Transformation API-based Batch M2M Transformation</h3>
<div class="sect3">
<h4 id="_introduction_3">Introduction</h4>
<div class="paragraph">
<p>The idea behind this transformation variant is similar in concept to the <a href="Simple Xtend and Query M2M transformation.html">Xtend and Query batch</a> variant. Traverse the model and transform the elements according to the specification using VIATRA Query patterns. The main difference is the usage of the VIATRA <a href="transformations.html">Batch Transformations and Statements API</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_how_does_it_work_3">How does it work</h4>
<div class="paragraph">
<p>In this variant the transformation steps are executed in the following order:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Transformation of the host instances</p>
<div class="ulist">
<ul>
<li>
<p>Create a new DeploymentHost in the deployment model representing the matched HostInstance. Add trace to traceability.</p>
</li>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>hostInstance</em></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Transformation of the application instances</p>
<div class="ulist">
<ul>
<li>
<p>Create a new DeploymentApplication in the deployment model representing the matched ApplicationInstance. Add trace to traceability.</p>
</li>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>applicationInstance</em></p>
</li>
<li>
<p><em>cps2depTrace</em></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Transformation of the state machines</p>
<div class="ulist">
<ul>
<li>
<p>Create a new DeploymentBehavior in the deployment model representing the matched StateMachine for the ApplicationInstance specified by the pattern. This happens for every ApplicationInstance with a type that defines the StateMachine. Add DeploymentBehavior to proper trace in traceability. If it does not exist, create it.</p>
</li>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>appInstanceWithStateMachine</em></p>
</li>
<li>
<p><em>applicationInstance</em></p>
</li>
<li>
<p><em>cps2depTrace</em></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Transformation of the states of the state machines</p>
<div class="ulist">
<ul>
<li>
<p>Create a new BehaviorState in the deployment model representing the matched State for the ApplicationInstance specified by the pattern. This happens for every ApplicationInstance with a type that defines the StateMachine containing the State. Set the DeploymentBehavior&#8217;s current state to the created BehaviorState if the original State was an initial state of it&#8217;s state machine. Add BehaviorState to proper trace in traceability. If it does not exist, create it.</p>
</li>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>state</em></p>
</li>
<li>
<p><em>appInstanceWithStateMachine</em></p>
</li>
<li>
<p><em>applicationInstance</em></p>
</li>
<li>
<p><em>cps2depTrace</em></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Transformation of the transitions of the state machines</p>
<div class="ulist">
<ul>
<li>
<p>Create a new BehaviorTransition in the deployment model representing the matched State for the ApplicationInstance specified by the pattern. This happens for every ApplicationInstance with a type that defines the StateMachine containing the State containing the Transition. Add BehaviorTransition to proper trace in traceability. If it does not exist, create it.</p>
</li>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>transition</em></p>
</li>
<li>
<p><em>state</em></p>
</li>
<li>
<p><em>appInstanceWithStateMachine</em></p>
</li>
<li>
<p><em>applicationInstance</em></p>
</li>
<li>
<p><em>cps2depTrace</em></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Transformation of actions of the transitions</p>
<div class="ulist">
<ul>
<li>
<p>Set the trigger between the BehaviorTransitions representing the matched Transitions.</p>
</li>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>action</em></p>
</li>
<li>
<p><em>sendAction</em></p>
</li>
<li>
<p><em>waitAction</em></p>
</li>
<li>
<p><em>actionPair</em></p>
</li>
<li>
<p><em>reachableHosts</em></p>
</li>
<li>
<p><em>transition</em></p>
</li>
<li>
<p><em>state</em></p>
</li>
<li>
<p><em>appInstanceWithStateMachine</em></p>
</li>
<li>
<p><em>applicationInstance</em></p>
</li>
<li>
<p><em>cps2depTrace</em></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_handling_of_1_to_n_mappings_3">Handling of 1-to-n mappings</h4>
<div class="paragraph">
<p>The 1-to-n mappings are mainly handled inside the VIATRA Query patterns. Each pattern is written in a way so that it will match each applicable ApplicationInstance, e.g. if a State exists the CPS model and there are 3 ApplicationInstances of the type that defines the StateMachine, then 3 matches will occur, and each of them will add a new BehaviorState to the corresponding DeploymentApplication&#8217;s DeploymentBehavior.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creation_of_triggers_3">Creation of triggers</h4>
<div class="paragraph">
<p>The creation of the triggers was mostly done leveraging the power of VIATRA Query.</p>
</div>
<div class="paragraph">
<p>The main pattern used is the one named "actionPair". This pattern returns a Transition with send action, another Transition with the corresponding wait action and an application instance for each of these transitions.</p>
</div>
<div class="paragraph">
<p>The other important pattern is "reachableHosts". This pattern searches for every HostInstance pair that can directly communicate with each other. Using this pattern we can filter the results of the "actionPair" pattern so we only have to handle the relevant action pair - aplication instance combinations.</p>
</div>
</div>
<div class="sect3">
<h4 id="_class_of_the_transformation_2">Class of the transformation</h4>
<div class="paragraph">
<p>The implementation of the transformation can be found in the following class:
<code>CPS2DeploymentBatchViatra.xtend</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_summary_and_comparison_3">Summary and comparison</h4>
<div class="paragraph">
<p>If compared to the batch VIATRA Query variant, while being simpler and easier to maintain than its counterpart due to the simplified, more transformation oriented VIATRA API, this implementation offers the same functionality and performance as well.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_explicit_traceability_m2m_transformation">Explicit Traceability M2M Transformation</h3>
<div class="paragraph">
<p>This page contains the documentation of the incremental model transformation using Xtend and VIATRA Query with the  explicit traceability model used for identifying unsynchronized changes between the CPS and deployment models.</p>
</div>
<div class="sect3">
<h4 id="_introduction_4">Introduction</h4>
<div class="paragraph">
<p>This transformation variant uses the <a href="evm.html">Event-driven Virtual Machine (EVM)</a> that is part of VIATRA for specifying and executing a set of independent transformation rules. The rules are developed to monitor the traceability model between a CPS and a deployment model and any element in the CPS model without corresponding traces is transformed to synchronize the CPS and deployment models.</p>
</div>
</div>
<div class="sect3">
<h4 id="_how_does_it_work_4">How does it work</h4>
<div class="paragraph">
<p>For each type in the CPS metamodel, we create several rules for identifying their appearance, disappearance and optionally updates. The preconditions of these rules are defined by VIATRA Query patterns <a href="https://git.eclipse.org/c/viatra/org.eclipse.viatra.examples.git/tree/cps/transformations/org.eclipse.viatra.examples.cps.xform.m2m.incr.expl/src/org/eclipse/viatra/examples/cps/xform/m2m/incr/expl/queries/cpsXformM2M.vql">cpsXformM2M.vql</a> with the following naming convention:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>unmappedCPSElement</strong>: match a <em>CPSElement</em> (e.g. host instance) that has no corresponding trace</p>
</li>
<li>
<p><strong>monitoredCPSElement</strong>: match a <em>CPSElement</em> that has complete trace</p>
</li>
<li>
<p><strong>deletedDeploymentElement</strong>: match a <em>DeploymentElement</em> that has a trace, but the related CPS element does not exist</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The naming convention of <a href="https://git.eclipse.org/c/viatra/org.eclipse.viatra.examples.git/tree/cps/transformations/org.eclipse.viatra.query.examples.cps.xform.m2m.incr.expl/src/org/eclipse/viatra/query/examples/cps/xform/m2m/incr/expl/rules">rules</a> that use these patterns is the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>CPSElementMapping</strong>: matches of <em>unmappedCPSElement</em> pattern are processed to create corresponding elements in the deployment model (e.g. DeploymentApplication for ApplicationInstance) and the trace</p>
</li>
<li>
<p><strong>CPSElementUpdate</strong>: matches of <em>monitoredCPSElement</em> pattern are processed to monitor the <em>CPSElement</em> and synchronize attribute changes (e.g. the IP of the host instance is changed)</p>
</li>
<li>
<p><strong>CPSElementRemoval</strong>: matches of <em>deletedDeploymentElement</em> pattern are processed to remove the corresponding elements from the deployment model and the trace</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are rules defined for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Host instances</p>
</li>
<li>
<p>Application instances allocated to mapped hosts</p>
</li>
<li>
<p>State machines for each mapped application instance</p>
</li>
<li>
<p>States</p>
</li>
<li>
<p>Transitions</p>
</li>
<li>
<p>Triggers (<em>update is not used</em>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The transformation execution is completely event-driven, without any priority between rules or imperative control structures. The set of rules are collected and an execution schema is created with a scheduler that is called every time the model has changed. The scheduler invokes the EVM executor that fires all activations that are enabled for any of the rules. Activations are not ordered in any way, the executor simply takes the next enabled in a while loop that runs as long as there is any enabled activation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_handling_of_1_to_n_mappings_4">Handling of 1-to-n mappings</h4>
<div class="paragraph">
<p>Since the transformation watches the traceability model, a missing mapping for any 1-to-n mapping is represented as a match of the corresponding <em>unmappedCPSElement</em> pattern. If an application type has 3 instances which are already transformed then there will be 3 <em>unmappedStateMachine</em> matches and also 3 activations of the <em>StateMachineMapping</em> rule.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creation_of_triggers_4">Creation of triggers</h4>
<div class="paragraph">
<p>Triggers are found in the CPS model by VIATRA Query patterns that evaluate the actions of transitions, check communication between host instance and check allocation of application instances to hosts. In addition, the traceability model is used to find those BehaviorTransition elements that correspond to the CPS transitions. Note that this is needed since instances of the application type may be allocated to different hosts. Therefore, two CPS transitions with matching send and wait actions may only represent triggers for some or none of the application instances.</p>
</div>
</div>
<div class="sect3">
<h4 id="_technical_details">Technical details</h4>
<div class="sect4">
<h5 id="_api">API</h5>
<div class="paragraph">
<p>The API of the transformation is the following class:
<code>CPS2DeploymentTransformation.xtend</code> (<a href="https://git.eclipse.org/c/viatra/org.eclipse.viatra.examples.git/tree/cps/transformations/org.eclipse.viatra.query.examples.cps.xform.m2m.incr.expl/src/org/eclipse/viatra/query/examples/cps/xform/m2m/incr/expl/CPS2DeploymentTransformation.xtend">source</a>)</p>
</div>
</div>
<div class="sect4">
<h5 id="_usage_example">Usage example</h5>
<div class="paragraph">
<p>The following is a simple example for executing the transformation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">// assume cps2dep is a CPSToDeployment object
// assume engine is an VIATRA Query engine initialized on the resource set containing cps2dep
xform = new CPS2DeploymentTransformation
xform.initialize(cps2dep, engine)
xform.execute()
// model changes are incrementally synchronized
// calling execute later has no effect
xform.dispose</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_summary_and_comparison_4">Summary and comparison</h4>
<div class="paragraph">
<p>The explicit traceability variant implements the CPS-to-Deployment transformation by watching the state of the traceability model and synchronizes any changes incrementally from the CPS model to the Deployment model. After the initial execution (when the traceability and deployment models are empty), the event-driven rules are executed whenever model changes happen and only changed elements are transformed instead of the whole model. Additionally, this variant can be started even if the CPS, deployment and traceability models are already transformed (e.g. by a batch transformation) and it is able to correctly work incrementally from that point. Compared to the <a href="#_query_result_traceability_m2m_transformation">Query result traceability M2M transformation</a>, it behaves correctly even if only the CPS model has been changed after a previous transformation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_query_result_traceability_m2m_transformation">Query result traceability M2M transformation</h3>
<div class="paragraph">
<p>This gives a short introduction on the incremental query result traceability M2M transformation.</p>
</div>
<div class="sect3">
<h4 id="_introduction_5">Introduction</h4>
<div class="paragraph">
<p>This transformation variant is closely related to the <a href="#_explicit_traceability_m2m_transformation">Explicit Traceability</a> variant. The concept of this transformation method is to use VIATRA Query patterns on the CPS model and react to changes in the match results by updating the deployment and traceability models incrementally.</p>
</div>
</div>
<div class="sect3">
<h4 id="_how_does_it_work_5">How does it work</h4>
<div class="paragraph">
<p>This transformation method is heavily based on the <a href="evm.html">Event-driven Virtual Machine (EVM)</a> provided by VIATRA. Each transformation step is triggered by an appearing or disappearing VIATRA Query pattern match. The transformation steps are detailed in the listing below.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>HostInstance</strong></p>
<div class="ulist">
<ul>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>hostInstance</em> (Event Trigger)</p>
</li>
<li>
<p><em>cps2depTrace</em> (Used in transformation)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Appear: Create a new DeploymentHost in the deployment model representing the appeared HostInstance. Add trace to traceability.</p>
</li>
<li>
<p>Update: Update the IP address if required.</p>
</li>
<li>
<p>Disappear: Remove the DeploymentHost representing the disappeared HostInstance from the deployment model. Remove trace from traceability.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>ApplicationInstance</strong></p>
<div class="ulist">
<ul>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>applicationInstance</em> (Event Trigger)</p>
</li>
<li>
<p><em>cps2depTrace</em> (Used in transformation)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Appear: Create a new DeploymentApplication in the deployment model representing the appeared ApplicationInstance. Add trace to traceability.</p>
</li>
<li>
<p>Update: Update the id if required.</p>
</li>
<li>
<p>Disappear: Remove the DeploymentApplication representing the disappeared ApplicationInstance from the deployment model. Remove trace from traceability.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>StateMachine</strong></p>
<div class="ulist">
<ul>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>stateMachine</em> (Event Trigger)</p>
</li>
<li>
<p><em>applicationInstance</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>cps2depTrace</em> (Used in transformation)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Appear: Create a new DeploymentBehavior in the deployment model representing the appeared StateMachine for the ApplicationInstance specified by the pattern. This happens for every ApplicationInstance with a type that defines the StateMachine. Add DeploymentBehavior to proper trace in traceability. If it does not exist, create it.</p>
</li>
<li>
<p>Update: Update the description if required.</p>
</li>
<li>
<p>Disappear: Remove the DeploymentBehaviors representing the disappeared StateMachines from the deployment model. Remove DeploymentBehavior from proper trace in traceability. If no DeploymentBehaviors are left in the trace, remove it.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>State</strong></p>
<div class="ulist">
<ul>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>state</em> (Event Trigger)</p>
</li>
<li>
<p><em>stateMachine</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>applicationInstance</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>cps2depTrace</em> (Used in transformation)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Appear: Create a new BehaviorState in the deployment model representing the appeared State for the ApplicationInstance specified by the pattern. This happens for every ApplicationInstance with a type that defines the StateMachine containing the State. Set the DeploymentBehavior&#8217;s current state to the created BehaviorState if the original State was an initial state of it&#8217;s state machine. Add BehaviorState to proper trace in traceability. If it does not exist, create it.</p>
</li>
<li>
<p>Update: Update the description and the current state of the state machine if required.</p>
</li>
<li>
<p>Disappear: Remove the BehaviorStates representing the disappeared State from the deployment model. If this BehaviorState was the current state of it&#8217;s DeploymentBehavior, set the behavior&#8217;s current state to null. Remove BehaviorStates from proper trace in traceability. If no BehaviorStates are left in the trace, remove it.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Transition</strong></p>
<div class="ulist">
<ul>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>transition</em> (Event Trigger)</p>
</li>
<li>
<p><em>state</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>stateMachine</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>applicationInstance</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>cps2depTrace</em> (Used in transformation)</p>
</li>
<li>
<p><em>depBehaviorsStateAndTransitions</em> (Used in transformation)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Appear: Create a new BehaviorTransition in the deployment model representing the appeared State for the ApplicationInstance specified by the pattern. This happens for every ApplicationInstance with a type that defines the StateMachine containing the State containing the Transition. Add BehaviorTransition to proper trace in traceability. If it does not exist, create it.</p>
</li>
<li>
<p>Update: Update the description, the source and target states if required.</p>
</li>
<li>
<p>Disappear: Remove the BehaviorTransitions representing the disappeared Transition from the deployment model. Remove BehaviorTransitions from proper trace in traceability. If no BehaviorTransitions are left in the trace, remove it.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Trigger</strong></p>
<div class="ulist">
<ul>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>triggerPair</em> (Event Trigger)</p>
</li>
<li>
<p><em>sendTransitionAppSignal</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>waitTransitionAppSignal</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>appInstanceTransition</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>applicationInstance</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>applicationInstanceWithHost</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>reachableHosts</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>hostCommunication</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>cps2depTrace</em> (Used in transformation)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Appear: Set the trigger between the BehaviorTransitions representing the matched Transitions.</p>
</li>
<li>
<p>Disappear: Remove the trigger between the BehaviorTransitions representing the matched Transitions.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>To resolve ordering issues, the events processing order is defined based on priorities as follows:
HostInstance &gt; ApplicationInstance &gt; StateMachine &gt; State &gt; Transition &gt; Trigger</p>
</div>
<div class="paragraph">
<p>(A &gt; B means event A will be processed before event B)</p>
</div>
<div class="paragraph">
<p>The above order is true for each appear and update event. In the case of disappear events the order is reversed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_handling_of_1_to_n_mappings_5">Handling of 1-to-n mappings</h4>
<div class="paragraph">
<p>The 1-to-n mappings are mainly handled inside the event trigger patterns. Each pattern is written in a way so that it will create an event for each applicable ApplicationInstance, e.g. if a new State is added to the CPS model and there are 3 ApplicationInstances of the type that defines the StateMachine, then 3 appeared events will occur, and each of them will add a new BehaviorState to the corresponding DeploymentApplication&#8217;s DeploymentBehavior.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creation_of_triggers_5">Creation of triggers</h4>
<div class="paragraph">
<p>Detecting new trigger pairs is entirely the job of VIATRA Query using the above specified patterns.</p>
</div>
</div>
<div class="sect3">
<h4 id="_class_of_the_transformation_3">Class of the transformation</h4>
<div class="paragraph">
<p>The implementation of the transformation can be found in the following class:
<code>CPS2DeploymentTransformationQrt.xtend</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_summary_and_comparison_5">Summary and comparison</h4>
<div class="paragraph">
<p>Compared to the Explicit Traceability version, the reduced pattern complexity of this transformation method allows more memory efficient transformation at the price of loosing the ability to start the transformation on an already existing, partially transformed model. The speed of the transformation is comparable to that of the Explicit Traceability, while its memory consumption is more akin to the <a href="#_simple_xtend_and_query_m2m_transformation">Simple Xtend and Query</a> variant.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_partial_batch_m2m_transformation">Partial batch M2M transformation</h3>
<div class="paragraph">
<p>This page provides a summary for the partial batch transformation.</p>
</div>
<div class="sect3">
<h4 id="_introduction_6">Introduction</h4>
<div class="paragraph">
<p>The partial batch transformation performs an initial, complete transformation for the model, which is basically the simple VIATRA Query solution described in <a href="#_simple_xtend_and_query_m2m_transformation">Simple Xtend and Query M2M-transformation</a>. Then, the changes of the source CyberPhysicalSystem model are traced and collected using a change monitor. From the collected changes in source cyber physical system model the transformation - when run again - modifies only the corresponding parts of the deployment model, this way dramatically reducing re-transformation time if the source model contains changes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_how_does_it_work_6">How does it work</h4>
<div class="paragraph">
<p>This transformation uses the <a href="evm.html">Event-driven Virtual Machine (EVM)</a> feature of VIATRA Query. Registrations of changes are triggered by an appearing or disappearing VIATRA Query pattern match. Based on the appearance, disappearance or update of a model element since the last transformation, actions are to be taken when the transformation is initiated again.</p>
</div>
<div class="paragraph">
<p>The VIARA Query query definitions used for the transformation of the model elements are detailed below.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>hostInstances</strong></p>
<div class="ulist">
<ul>
<li>
<p>Finds all host instances who have host type assigned.</p>
</li>
<li>
<p>Used for transforming host instances to deployment hosts. The attribute values are obtained from the host instance object.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>appInstances</strong></p>
<div class="ulist">
<ul>
<li>
<p>Finds all application instance which have application type.</p>
</li>
<li>
<p>Used for creating deployment applications.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>appTypes</strong></p>
<div class="ulist">
<ul>
<li>
<p>Returns all application types in the cyber physical system model.</p>
</li>
<li>
<p>Used for determining the state machine application based on the type. The state machine is transformed to a behavior using the rule assigned to the <code>stateMachines</code> pattern.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>stateMachines</strong></p>
<div class="ulist">
<ul>
<li>
<p>Gets the state machines assigned to any application type.</p>
</li>
<li>
<p>Used for creating behaviors of deployment applications.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>states</strong></p>
<div class="ulist">
<ul>
<li>
<p>Returns states that are part of a given state machine.</p>
</li>
<li>
<p>Used for the creation of deployment behavior states within a behavior.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>transitions</strong></p>
<div class="ulist">
<ul>
<li>
<p>Gets all transitions that are outgoing transitions of a state.</p>
</li>
<li>
<p>Based on the matches of this pattern behavior transitions and triggers between them are created.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_handling_of_1_to_n_mappings_6">Handling of 1-to-n mappings</h4>
<div class="paragraph">
<p>The 1-to-n mappings are handled within a separate method called <code>addTraceOneToN</code>. This is required for transforming state machines, states and transitions. When deletions occur in the source model, then the corresponding mappings are found using an VIATRA Query matcher, then removed by hand from the mappings.</p>
</div>
</div>
<div class="sect3">
<h4 id="_class_of_the_transformation_4">Class of the transformation</h4>
<div class="paragraph">
<p>The implementation of the transformation can be found in the following class:
<code>CPS2DeploymentPartialBatchTransformationEiq.xtend</code>, which is located in the <code>org.eclipse.viatra.query.examples.cps.xform.m2m.incr.aggr</code> package.</p>
</div>
</div>
<div class="sect3">
<h4 id="_summary_2">Summary</h4>
<div class="paragraph">
<p>This transformation has almost the same memory footprint as the batch VIATRA Query transformation. The first transformation time is about the same, however, the time needed to transform the changes in the initial model is half the time needed for the batch VIATRA Query variant.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_viatra_transformation_api_based_qrt_m2m_transformation">VIATRA transformation API based QRT M2M transformation</h3>
<div class="paragraph">
<p>This gives a short introduction on the QRT transformation variant that uses the VIATRA transformation API to define its transformation rules.</p>
</div>
<div class="sect3">
<h4 id="_introduction_7">Introduction</h4>
<div class="paragraph">
<p>This transformation variant is closely related to the <a href="#_query_result_traceability_m2m_transformation">Query Result Tracebility</a> variant. The basic concept of the transformation and the transformation rules are identical to those of the aforementioned variant, as the VIATRA transformation API basically provides a simplified, more model transformation oriented interface for the <a href="evm.html">Event-driven Virtual Machine (EVM)</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_how_does_it_work_7">How does it work</h4>
<div class="paragraph">
<p>On the contrary to its sister variant, this method uses the <a href="transformations.html">VIATRA transformation API</a> to access the EVM. Similar to the aforementioned QRT method, each transformation step is triggered by an appearing or disappearing VIATRA Query pattern match. The transformation steps are detailed in the listing below.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>HostInstance</strong></p>
<div class="ulist">
<ul>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>hostInstance</em> (Event Trigger)</p>
</li>
<li>
<p><em>cps2depTrace</em> (Used in transformation)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Appear: Create a new DeploymentHost in the deployment model representing the appeared HostInstance. Add trace to traceability.</p>
</li>
<li>
<p>Update: Update the IP address if required.</p>
</li>
<li>
<p>Disappear: Remove the DeploymentHost representing the disappeared HostInstance from the deployment model. Remove trace from traceability.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>ApplicationInstance</strong></p>
<div class="ulist">
<ul>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>applicationInstance</em> (Event Trigger)</p>
</li>
<li>
<p><em>cps2depTrace</em> (Used in transformation)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Appear: Create a new DeploymentApplication in the deployment model representing the appeared ApplicationInstance. Add trace to traceability.</p>
</li>
<li>
<p>Update: Update the id if required.</p>
</li>
<li>
<p>Disappear: Remove the DeploymentApplication representing the disappeared ApplicationInstance from the deployment model. Remove trace from traceability.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>StateMachine</strong></p>
<div class="ulist">
<ul>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>stateMachine</em> (Event Trigger)</p>
</li>
<li>
<p><em>applicationInstance</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>cps2depTrace</em> (Used in transformation)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Appear: Create a new DeploymentBehavior in the deployment model representing the appeared StateMachine for the ApplicationInstance specified by the pattern. This happens for every ApplicationInstance with a type that defines the StateMachine. Add DeploymentBehavior to proper trace in traceability. If it does not exist, create it.</p>
</li>
<li>
<p>Update: Update the description if required.</p>
</li>
<li>
<p>Disappear: Remove the DeploymentBehaviors representing the disappeared StateMachines from the deployment model. Remove DeploymentBehavior from proper trace in traceability. If no DeploymentBehaviors are left in the trace, remove it.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>State</strong></p>
<div class="ulist">
<ul>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>state</em> (Event Trigger)</p>
</li>
<li>
<p><em>stateMachine</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>applicationInstance</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>cps2depTrace</em> (Used in transformation)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Appear: Create a new BehaviorState in the deployment model representing the appeared State for the ApplicationInstance specified by the pattern. This happens for every ApplicationInstance with a type that defines the StateMachine containing the State. Set the DeploymentBehavior&#8217;s current state to the created BehaviorState if the original State was an initial state of it&#8217;s state machine. Add BehaviorState to proper trace in traceability. If it does not exist, create it.</p>
</li>
<li>
<p>Update: Update the description and the current state of the state machine if required.</p>
</li>
<li>
<p>Disappear: Remove the BehaviorStates representing the disappeared State from the deployment model. If this BehaviorState was the current state of it&#8217;s DeploymentBehavior, set the behavior&#8217;s current state to null. Remove BehaviorStates from proper trace in traceability. If no BehaviorStates are left in the trace, remove it.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Transition</strong></p>
<div class="ulist">
<ul>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>transition</em> (Event Trigger)</p>
</li>
<li>
<p><em>state</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>stateMachine</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>applicationInstance</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>cps2depTrace</em> (Used in transformation)</p>
</li>
<li>
<p><em>depBehaviorsStateAndTransitions</em> (Used in transformation)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Appear: Create a new BehaviorTransition in the deployment model representing the appeared State for the ApplicationInstance specified by the pattern. This happens for every ApplicationInstance with a type that defines the StateMachine containing the State containing the Transition. Add BehaviorTransition to proper trace in traceability. If it does not exist, create it.</p>
</li>
<li>
<p>Update: Update the description, the source and target states if required.</p>
</li>
<li>
<p>Disappear: Remove the BehaviorTransitions representing the disappeared Transition from the deployment model. Remove BehaviorTransitions from proper trace in traceability. If no BehaviorTransitions are left in the trace, remove it.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Trigger</strong></p>
<div class="ulist">
<ul>
<li>
<p>Related patterns:</p>
<div class="ulist">
<ul>
<li>
<p><em>triggerPair</em> (Event Trigger)</p>
</li>
<li>
<p><em>sendTransitionAppSignal</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>waitTransitionAppSignal</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>appInstanceTransition</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>applicationInstance</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>applicationInstanceWithHost</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>reachableHosts</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>hostCommunication</em> (Referenced by event trigger)</p>
</li>
<li>
<p><em>cps2depTrace</em> (Used in transformation)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Appear: Set the trigger between the BehaviorTransitions representing the matched Transitions.</p>
</li>
<li>
<p>Disappear: Remove the trigger between the BehaviorTransitions representing the matched Transitions.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>To resolve ordering issues, the events processing order is defined based on priorities as follows:
HostInstance &gt; ApplicationInstance &gt; StateMachine &gt; State &gt; Transition &gt; Trigger</p>
</div>
<div class="paragraph">
<p>(A &gt; B means event A will be processed before event B)</p>
</div>
<div class="paragraph">
<p>The above order is true for each appear and update event. In the case of disappear events the order is reversed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_handling_of_1_to_n_mappings_7">Handling of 1-to-n mappings</h4>
<div class="paragraph">
<p>The 1-to-n mappings are mainly handled inside the event trigger patterns. Each pattern is written in a way so that it will create an event for each applicable ApplicationInstance, e.g. if a new State is added to the CPS model and there are 3 ApplicationInstances of the type that defines the StateMachine, then 3 appeared events will occur, and each of them will add a new BehaviorState to the corresponding DeploymentApplication&#8217;s DeploymentBehavior.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creation_of_triggers_6">Creation of triggers</h4>
<div class="paragraph">
<p>Detecting new trigger pairs is entirely the job of VIATRA Query using the above specified patterns.</p>
</div>
</div>
<div class="sect3">
<h4 id="_class_of_the_transformation_5">Class of the transformation</h4>
<div class="paragraph">
<p>The implementation of the transformation can be found in the following class:
<code>CPS2DeploymentTransformationViatra.xtend</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_summary_and_comparison_6">Summary and comparison</h4>
<div class="paragraph">
<p>If compared to the QRT variant, while being simpler and easier to maintain than its counterpart due to the simplified, more transformation oriented VIATRA API, this implementation offers the same functionality and performance as well.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cps_to_deployment_unit_tests">CPS to Deployment Unit Tests</h3>
<div class="paragraph">
<p>The <code>xform.m2m.tests</code> project specifies a high number of test cases that are independent of transformation implementations and are created for allowing Test Driven Development of transformations based on the specification.</p>
</div>
<div class="paragraph">
<p>The tests are grouped together into classes following the rules found in the specification of the CPS-to-Deployment transformation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HostMappingTest</p>
</li>
<li>
<p>ApplicationMappingTest</p>
</li>
<li>
<p>StateMachineMappingTest</p>
</li>
<li>
<p>StateMappingTest</p>
</li>
<li>
<p>TransitionMappingTest</p>
</li>
<li>
<p>ActionMappingTest</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, the <code>TransformationApiTest</code> class ensures that all variants behave the same way for incorrect input parameters, while the <code>WrapperTest</code> class can contain additional tests for specific transformation variant wrappers.</p>
</div>
<div class="sect3">
<h4 id="_technical_details_2">Technical details</h4>
<div class="sect4">
<h5 id="_run_the_tests">Run the tests</h5>
<div class="paragraph">
<p>Simply right-click on the <code>xform.m2m.tests</code> project and select <code>Run as&#8230;&#8203; &#8594; JUnit Plugin Test</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_test_case_structure">Test case structure</h5>
<div class="paragraph">
<p>All specification related tests extend the <code>CPS2DepTest</code> class, which defines some extension fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">class CPS2DepTest {
    protected extension Logger logger = Logger.getLogger("cps.xform.CPS2DepTest")
    protected extension CPSTransformationWrapper xform
    protected extension CPSModelBuilderUtil modelBuilder</code></pre>
</div>
</div>
<div class="paragraph">
<p>A simple test case is structured as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">@Test
def hostIncremental() {
 val testId = "hostIncremental"
 info("START TEST: " + testId)

 // use model builder to create initial model
 val cps2dep = prepareEmptyModel(testId)

 // use transformation wrapper to initialize (e.g. create rules)
 cps2dep.initializeTransformation
 // use transformation wrapper to execute
 executeTransformation

 // modify model
 val instance = cps2dep.prepareHostInstance
 // re-execute transformation (incremental usually ignores this call)
 executeTransformation

 // check results
 cps2dep.assertHostMapping(instance)

 info("END TEST: " + testId)
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_test_with_existing_input_model">Test with existing input model</h5>
<div class="paragraph">
<p>If you would like to test the transformation on your own input CPS model, take a look at the <code>specificInputModel</code> test case in <code>InstanceModelTest.xtend</code> in the <code>&lt;cps&gt;.xform.m2m.tests.integration</code> package.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">@Ignore
@Test
def specificInputModel(){
  val testId = "specificInputModel"
  info("START TEST: " + testId)

  val cpsUri = "file://my-cps-git-location/models/org.eclipse.viatra.query.examples.cps.instances/example.cyberphysicalsystem"

  val cps2dep = prepareCPSModel(cpsUri)

  cps2dep.initializeTransformation
  executeTransformation

  info("END TEST: " + testId)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just change the resource URI to a full file path, remove or comment out the <code>@Ignore</code> and run the tests.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_code_generator_distributed_realization_xtend_templates">Code Generator (Distributed realization - Xtend templates)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>org.eclipse.viatra.query.examples.cps.m2t.distributed.generator</code> project implements a basic model-to-text transformation. It is a basic template based generator written in <em>Xtend</em> .</p>
</div>
<div class="sect2">
<h3 id="_deployment_realization">Deployment realization</h3>
<div class="paragraph">
<p>The generated Java code realizes a "<em>distributed</em>" <code>Deployment</code> model where <code>Hosts</code> are the base elements of the distribution. Each host is a separated entity which can be run on <code>HostRunner</code> (threads). Hosts can communicate with each other via the <code>CommunicationNetwork</code> shared object.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/cps/codegenerator.png" alt="Code Generator">
</div>
</div>
<div class="paragraph">
<p><code>Hosts</code> and <code>Applications</code> are data objects with states. <code>HostRunner</code> is a simple engine which triggers its hosts to fire available transitions on every applications. The communication is asynchronous and realized with queues.</p>
</div>
</div>
<div class="sect2">
<h3 id="_code_generator">Code Generator</h3>
<div class="paragraph">
<p>The public API of the transformation contains four methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">interface ICPSGenerator {
    def CharSequence generateHostCode(DeploymentHost host) throws CPSGeneratorException
    def CharSequence generateApplicationCode(DeploymentApplication application) throws CPSGeneratorException
    def CharSequence generateBehaviorCode(DeploymentBehavior behavior) throws CPSGeneratorException
    def CharSequence generateDeploymentCode(Deployment deployment) throws CPSGeneratorException
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This implementation of the code generator is stateless. Each separate model element is generated individually.</p>
</div>
<div class="sect3">
<h4 id="_host">Host</h4>
<div class="paragraph">
<p>The host objects keep references to their own applications.</p>
</div>
<div class="listingblock">
<div class="title">Generated Code</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Host152661025 extends BaseHost {

    public Host152661025(CommunicationNetwork network) {
        super(network);
        // Add Applications of Host
        applications = Lists.&lt;Application&gt;newArrayList(
            new AlarmApplication(this),
                        new OtherApplication(this),
        );
    }

}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_application">Application</h5>
<div class="paragraph">
<p>Applications store their <code>ApplicationID</code> and their current state of the behavior (State machine).</p>
</div>
<div class="listingblock">
<div class="title">Generated Code</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class AlarmApplication extends BaseApplication&lt;BehaviorAlarmB&gt; {

    protected static final String APP_ID = "Alarm";

    public AlarmApplication(Host host) {
        super(host);

        // Set initial State
        currentState = BehaviorAlarmB.AInit;
    }

    @Override
    public String getAppID() {
        return APP_ID;
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_behavior">Behavior</h4>
<div class="paragraph">
<p>Behavior represents a statemachine of the application. It stores and manages the possible state transitions.</p>
</div>
<div class="listingblock">
<div class="title">Generated Code</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public enum BehaviorAlarmB implements State&lt;BehaviorAlarmB&gt; {
     ///////////
    // States
    AInit {
        @Override
        public List&lt;State&lt;BehaviorAlarmB&gt;&gt; possibleNextStates(Application app) {
            List&lt;State&lt;BehaviorAlarmB&gt;&gt; possibleStates = Lists.newArrayList();

            // Add Neutral Transitions

            // Add Send Transitions
            possibleStates.add(ASent);

            // Add Wait Transitions

            return possibleStates;
        }

        @Override
        public BehaviorAlarmB stepTo(BehaviorAlarmB nextState, Application app) {
            // Send triggers
            if(nextState == ASent){
                app.sendTrigger("152.66.102.5", "Alarm", "ISSReceiving");
                return super.stepTo(nextState, app);
            }

            // Other cases (wait, neutral)
            return super.stepTo(nextState, app);
        }
    },
    ASent {
        @Override
        public List&lt;State&lt;BehaviorAlarmB&gt;&gt; possibleNextStates(Application app) {
            List&lt;State&lt;BehaviorAlarmB&gt;&gt; possibleStates = Lists.newArrayList();

            // Add Neutral Transitions
            possibleStates.add(AInit);

            // Add Send Transitions

            // Add Wait Transitions

            return possibleStates;
        }
    };

    private static Logger logger = Logger.getLogger("cps.proto.distributed.state");

     ////////////
    // Triggers

     /////////////////
    // General part
    @Override
    abstract public List&lt;State&lt;BehaviorAlarmB&gt;&gt; possibleNextStates(Application app);

    @Override
    public BehaviorAlarmB stepTo(BehaviorAlarmB nextState, Application app){
        if(possibleNextStates(app).contains(nextState)){
            logger.info("Step from " + this.name() + " to " + nextState.name());
            return nextState;
        }else{
            logger.info("!!! Warning: Unable to step from " + this.name() + " to " + nextState.name()
                    + " because the target state is not possible state.");
        }
        return this;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition to the generated code <code>org.eclipse.viatra.query.examples.cps.m2t.proto.distributed</code> project contains the shared part of the working code (<em>general</em> package). Implementation of the CommunicationNetwork, the HostRunner, the BaseApplication, the BaseHost, State and the interfaces are placed there.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_deployment_change_monitor">Deployment Change Monitor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This component tracks changes in the deployment model and informs the code generator about the changes.</p>
</div>
<div class="sect2">
<h3 id="_purpose_of_the_monitor">Purpose of the monitor</h3>
<div class="paragraph">
<p>The code generator produces simulation code for a DeploymentElement given to it. To decide whether a source file for a model element needs to be generated or not is beyond its responsibility. For this reason a DeploymentChangeMonitor is introduced and should be used during the behavior code generation process. This monitor tracks the changes of the model and is able to feed the generator with the DeploymentElements for which source code generation or re-generation is required. This solution will make overall time spent on code generation shorter, because only the changed model parts are considered.</p>
</div>
<div class="paragraph">
<p>The change monitor aggregates modifications into a delta between checkpoints. The API allows creating a new checkpoint and will provide the delta between the previous and newly created checkpoints, while it also starts to record the delta starting from the new checkpoint. The delta contains a boolean value to signify that the top-level configuration has to be re-generated and three sets of elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Appeared</strong> since the last checkpoint: source code related to these elements has to be generated, clean up not required</p>
</li>
<li>
<p><strong>Disappeared</strong> since the last checkpoint: source code related to these elements should be cleaned up</p>
</li>
<li>
<p><strong>Updated</strong> since the last breakpoint: source code related to these elements has to be re-generated, clean up may be needed (e.g. file name will change)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_it_work_8">How does it work</h3>
<div class="paragraph">
<p>The implemetation relies on the VIATRA Event-driven Virtual Machine (EVM). There are rules defined for the Deployment, DeploymentHost, DeploymentApplication and DeploymentBehavior types using VIATRA Query patterns. These rules describe the connections and properties of model elements that are to be monitored, and the DeploymentChangeMonitor keeps track of these changes. This is done by separate registered jobs for appear, update and disappear events.</p>
</div>
<div class="paragraph">
<p>The monitor inside stores three sets separately for appeared, updated and disappeared DeploymentElements, and a boolean flag is the Deployment is changed.</p>
</div>
<div class="paragraph">
<p>The rules used for monitoring:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Deployment is changed iff</p>
<div class="ulist">
<ul>
<li>
<p>Lists of host changed OR</p>
</li>
<li>
<p>IP of a contained Host is changed</p>
</li>
</ul>
</div>
</li>
<li>
<p>DeploymentHost is changed iff</p>
<div class="ulist">
<ul>
<li>
<p>Its list of applications is changed OR</p>
</li>
<li>
<p>Its IP changed</p>
</li>
</ul>
</div>
</li>
<li>
<p>DeploymentApplication is changed iff</p>
<div class="ulist">
<ul>
<li>
<p>Its ID changed OR</p>
</li>
<li>
<p>The current state of its DeploymentBehavior changed</p>
</li>
</ul>
</div>
</li>
<li>
<p>DeploymentBehavior is changed iff</p>
<div class="ulist">
<ul>
<li>
<p>The list of its states changed OR</p>
</li>
<li>
<p>The list of its transitions changed OR</p>
</li>
<li>
<p>For any transition the list of triggered transitions are changed</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_usage">Usage</h3>
<div class="paragraph">
<p>The implementation class for the monitor is the <code><code>org.eclipse.viatra.query.examples.cps.xform.m2t.DeploymentChangeMonitor</code></code> Java class. To use it, an ViatraQueryEngine and a Deployment needed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">engine = ViatraQueryEngine.on(deployment);
monitor = new DeploymentChangeMonitor(deployment,engine);
monitor.startMonitoring();</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get the change detlas a DeploymentChangeDelta DTO is returned by the getDeltaSinceLastCheckpoint() method of the monitor. This DTO also contains the information about the old names/IDs required for identifying the previously generated files that are to be deleted. This is in a map, that can be queried and used like in the code shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String oldId = monitor.deltaSinceLastCheckpoint.oldNamesForDeletion.get(deploymentElement);</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create a checkpoint in order to start collecting deltas to new empty collections the createCheckpoint() method can be used. This also returns a DeploymentChangeDelta containing all changes between the last two checkpoints.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_model_generator">Model Generator</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_example_model_generation">Example Model Generation</h3>
<div class="paragraph">
<p>You can generate CPS models with <code>SampleModelGenerator</code> class of the <code>org.eclipse.viatra.query.examples.cps.generator.tests</code> project.</p>
</div>
<div class="paragraph">
<p>How to use it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Remove the <code>@Ignore</code> annotation from the class</p>
</li>
<li>
<p>Run the class as JUnit Plug-in Test</p>
</li>
<li>
<p>Generated files will be in the <code>models</code> folder of the test project</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Currently generated example models:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DemoCPSConstraints</code></p>
</li>
<li>
<p><code>SimpleCPSConstraints</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you need other models you need to add other test cases to the class.</p>
</div>
</div>
<div class="sect2">
<h3 id="_configurable_model_generation">Configurable Model Generation</h3>
<div class="paragraph">
<p>Since manually creating large instance models requires a lot of effort, we developed a CPS Model Generator that executes a number of generation phases defined in a <a href="#_plan_executor">plan</a> and based on simple configuration can output <strong>arbitrarily large CPS models</strong>. The model generator is built in Xtend and uses VIATRA Query patterns for gathering elements for complex operations.</p>
</div>
<div class="paragraph">
<p>The model generator aims to output models that are similar in <strong>fine structure</strong> but have different number of elements (to generate scaled-up models) and allow some <strong>randomization</strong> (e.g. to create state machines with different number of states for different application types).</p>
</div>
<div class="paragraph">
<p>Randomization is controlled by min-max and percentage type parameters and ratio maps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <strong>min-max</strong> parameter specifies a range with a minimum and maximum value, while operations depending on the given parameter can obtain a random number that is part of the range (e.g. create statemachine with 5 to 10 states).</p>
</li>
<li>
<p>A <strong>percentage</strong> parameter specifies the fraction of a total, while operations may use it to decide how to distribute the choices for the possible elements (e.g. 35% of transitions in a state machine should have actions).</p>
</li>
<li>
<p>A <strong>ratio map</strong> parameter assigns integer values to classes, while operations may use it to distribute choices (e.g. how application instances are allocated to different host class instances).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The fine structure is specified with host and application classes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <strong>host class</strong> determines how many host types are created (min-max), how many instances are created for each type in the class (min-max), how many other host instance each host instance communicates with (min-max) and how the communications are distributed among instances of different host classes (ratio map).</p>
</li>
<li>
<p>An <strong>application class</strong> determines how many application types are created (min-max), how many instances are created for each type in the class (min-max), how many states and transitions should the state machine of each type contain (both min-max), how many of the instances are allocated (percentage), how is the allocation distributed among instances of different host classes (ratio map), how many of the transitions should define actions (percentage) and of those what is the ratio of sends (percentage).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Based on a list of host and application classes as input, the CPS model generator outputs an instance model that satisfies the constraints of the classes. While min-max parameters are always satisfied, percentage and ratio map parameters may not be precisely followed (e.g. allocating 35% of 10 applications may be 3 or 4). However, for larger sizes and in general, the generated model will have the structure specified in the classes.</p>
</div>
<div class="paragraph">
<p>The model generator component is able to generate <code>CyberPhysicalSystem</code> models with the specified properties.
The generator is built on top of the <a href="#_plan_executor">PlanExecutor</a> and implements specific plans, phases, operations, initializer and fragment objects. The generation process is based on pseudo-random actions which means the output is deterministic according to the input parameters.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./images/modelgenerator.png" alt="ModelGenerator"></span></p>
</div>
<div class="paragraph">
<p>Preferences of the model are declared in <code>ICPSConstraints</code> objects. The following constraints are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is able to define <em>Host</em> and <em>Application Classes</em> which specify constraints for <code>Host-</code> and <code>ApplicationTypes</code>. Each <em>HostClass</em> contains the following attributes:</p>
<div class="ulist">
<ul>
<li>
<p>Name: Name of the HostClass (important for the ids)</p>
</li>
<li>
<p>HostTypes: Min-Max value of the instantiated <code>HostTypes</code> (the exact value is randomized between the min and max values)</p>
</li>
<li>
<p>HostInstances: Min-Max value of the instantiated <code>HostInstances</code>. (the exact value is randomized separately for each <code>HostTypes</code> of the <em>HostClass</em>, between the min and max values)</p>
</li>
<li>
<p>CommunicationLines: This min-max value specifies the number of accessible <code>HostInstances</code> (<code>communicateWith</code> attribute).</p>
</li>
<li>
<p>CommunicationRatios: The accessible <code>HostInstances</code> are chosen from these <code>HostClasses</code> with the given ratio.</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>ApplicationClass</em> is defined with the following properties:</p>
<div class="ulist">
<ul>
<li>
<p>Name: Name of the ApplicationClass (important for the ids)</p>
</li>
<li>
<p>ApplicationTypes: Min-Max value of the instantiated <code>ApplicationTypes</code> (the exact value randomized between the min and max values)</p>
</li>
<li>
<p>ApplicationInstances: Min-Max value of the instantiated <code>ApplicationInstances</code>. (the exact value is randomized separately for each <code>ApplicationTypes</code> of the <em>ApplicationClass</em>, between the min and max values)</p>
</li>
<li>
<p>States: Min-Max value of the instantiated <code>States</code> for each <code>StateMachine</code> of the <code>ApplicationType</code></p>
</li>
<li>
<p>Transitions: Min-Max value of the instantiated <code>Transitions</code> for each <code>StateMachine</code> of the <code>ApplicationType</code></p>
</li>
<li>
<p>PercentageOfAllocatedInstances: Probability of application allocation</p>
</li>
<li>
<p>AllocationRatios: Describes the allocation ratio by <em>HostClasses</em></p>
</li>
<li>
<p>ProbabilityOfActionGeneration: probability of the action generation for <code>Transitions</code></p>
</li>
<li>
<p>ProbabilityOfSendAction: probability of generating <em>sendSignal</em> action (other is the <em>wiatForSignal</em>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Number of the available signals is specified with Min-Max value</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_cps_model_generation_plan">CPS model generation plan</h3>
<div class="paragraph">
<p><span class="image"><img src="./images/plan.png" alt="Plan of the CPS model generation"></span></p>
</div>
<div class="paragraph">
<p>The CPS plan consists of seven phases and eight operations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Prepare: prepare the IncQueryEngine</p>
</li>
<li>
<p>SignalSet: Generate signals</p>
</li>
<li>
<p>Types: Generate Host and Application types (include StateMachines) according to the <em>Classes</em></p>
</li>
<li>
<p>Instances: Generate Host and Application instances according to the <em>Classes</em></p>
</li>
<li>
<p>Host Communication: Add communication lines to <code>HostInstances</code></p>
</li>
<li>
<p>Allocations: Allocate <code>ApplicationInstances</code> to <code>HostInstances</code></p>
</li>
<li>
<p>Actions: Generate actions to <code>Transitions</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_usage_example_2">Usage example</h3>
<div class="paragraph">
<p>First, the <code>ICPSConstraints</code> interface shall be implemented.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">class SimpleCPSConstraints implements ICPSConstraints {

    override getName() {
        "Simple"
    }

    val hostClass1 = new HostClass(
        "FirstHostClass",
        new MinMaxData(1, 3), // HostTypes
        new MinMaxData(2, 5), // HostInstances
        new MinMaxData(1, 2), // CommLines
        new HashMap // CommRatios
    )
    val hostClass2 = new HostClass(
        "OtherHostClass",
        new MinMaxData(1, 1), // HostTypes
        new MinMaxData(2, 2), // HostInstances
        new MinMaxData(1, 1), // CommLines
        new HashMap // CommRatios
    )

    new() {
        for (class1 : hostClasses) {
            for (class2 : hostClasses) {
                class1.communicationRatios.put(class2, 1)
            }
        }
    }

    override getHostClasses() {
        #[hostClass1, hostClass2];
    }

    override getNumberOfSignals() {
        new MinMaxData(1, 10);
    }

    override getApplicationClasses() {
        val firstAppClassAllocations = new HashMap();
        firstAppClassAllocations.put(hostClass1, 1);
        firstAppClassAllocations.put(hostClass2, 2);

        #[
            new AppClass(
                "FirstAppClass",
                new MinMaxData(1, 3), // AppTypes
                new MinMaxData(1, 2), // AppInstances
                new MinMaxData(2, 4), // States
                new MinMaxData(1, 2), // Transitions
                new Percentage(100), // PercentageOfAllocatedInstances
                firstAppClassAllocations, // allocationRatios
                new Percentage(95), // probabilityOfActionGeneration
                new Percentage(60) // probabilityOfSendAction
            )
        ];
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This model shall contain least one and maximum three <code>HostTypes</code> of <em>FirstHostClass</em> and exactly one of the <em>OtherHostClass</em>. Each <code>HostType</code> of the <em>FirstHostClass</em> shall be instantiated minimum two and maximum five times and the <code>HostInstances</code> shall communicate with one or two other instances. The <em>OtherHostClass</em> is more stringent, it specifies the exact number of types, instances and communication lines (1,2,1). Instances can communicate with other instances from both <em>HostClass</em>es with equal possibility. Number of the generated signals shall be in range of 1 to 10. The SimpleCPSConstraints specifies only one <em>ApplicationClass</em>, the <em>FirstAppClass</em>. Least one and maximum three <em>ApplicationType</em> shall be created for this class. Each types of <em>FirstAppClass</em> shall be instantiated one or two times and the <code>StateMachine</code> of the types shall contain minimum two and maximum four <code>States</code> with one or two <code>Transactions</code>. Every <code>ApplicationInstance</code> shall be allocated (PercentageOfAllocatedInstances ). Two times more application instances shall be allocated on the instances of the <em>OtherHostClass</em> than the <em>FirstHostClass</em> (allocationRatios). Transitions contain actions with 95% and the probability of the "sendSignal" is 60%.</p>
</div>
<div class="paragraph">
<p>Then the <code>CPSGeneratorBuilder.buildAndGenerateModel(long seed, ICPSConstraints constraints) : CPSFragment</code> should be called.</p>
</div>
<div class="sect3">
<h4 id="_plan_executor">Plan Executor</h4>
<div class="paragraph">
<p>The PlanExecutor is a simple workflow engine which is able to execute plans. The plan is separated by phases which consist of Operations. The other input of the PlanExecutor is one of the <code>Initializer</code> interface implementation. <code>Initializer</code> shall initialize the Fragment object and it is able to store extra information for phases and operations. During the execution operations working on the shared object, called fragment. The output of the process is the fragment.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/cps/planexecutor.png" alt="PlanExecutor">
</div>
</div>
<div class="sect4">
<h5 id="_building_blocks">Building blocks</h5>
<div class="sect5">
<h6 id="_fragment">Fragment</h6>
<div class="paragraph">
<p>The fragment represents the artefact that the executor is operating on. In the CPS model generator, the fragment refers to the CPS instance model that is built. The fragment is introduced as a type parameter to ensure that operations can call the methods in a type-safe way on the fragment object.</p>
</div>
</div>
<div class="sect5">
<h6 id="_initializer">Initializer</h6>
<div class="paragraph">
<p>The initializer is responsible for creating an initial fragment object at the start of the execution. This approach allows the creation of the initializer object without performing possible expensive processing for creating the fragment before it is required.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">interface Initializer&lt;FragmentType&gt; {
    def FragmentType getInitialFragment();
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_operation">Operation</h6>
<div class="paragraph">
<p>Operations are defined for a given fragment type and are executed as part of phases. The same operation implementation may be used in multiple phases. The operation receives the fragment object as a parameter when it is executed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">interface IOperation&lt;FragmentType&gt; {
    def boolean execute(FragmentType fragment);
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_phase">Phase</h6>
<div class="paragraph">
<p>Phases represent standalone execution steps that define a list of operations on the same fragment type. The phase receives the fragment object as a parameter when assembling the operations, which means that the operation list can be dependent of the current state of the fragment.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">interface IPhase&lt;FragmentType&gt; {
    def Iterable&lt;IOperation&lt;FragmentType&gt;&gt; getOperations(FragmentType fragment);
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_plan">Plan</h6>
<div class="paragraph">
<p>The plan is created by adding phases that were already prepared by the same fragment. During the execution, the list of phases are requested by the executor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">interface IPlan&lt;FragmentType&gt; {
    def void addPhase(IPhase&lt;FragmentType&gt; phase);
    def Iterable&lt;IPhase&lt;FragmentType&gt;&gt; getPhases();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_technical_details_3">Technical details</h5>
<div class="paragraph">
<p>First step is to create custom implementations of <code>IPlan</code>, <code>IPhase</code>, <code>IOperation</code>, <code>Initializer</code> interfaces and create the <code>Fragment</code> type like in the followings.</p>
</div>
<div class="listingblock">
<div class="title">MyFragment</div>
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">class MyFragment {
    SecretStore secretStore = "";

    def addSecretInformation(String info) {
        secretStore.add(info);
    }

    def encryptStore() {
        secretStore.encrypt;
    }

    def print() {
        secretStore.print;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">MyInitializer</div>
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">class MyInitializer implements Initializer&lt;MyFragment&gt; {

    override getInitialFragment() {
        return new MyFragment();
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">MyPlan</div>
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">class MyPlan implements IPlan&lt;MyFragment&gt; {

    List&lt;IPhase&lt;MyFragment&gt;&gt; phases = Lists.newArrayList;

    override addPhase(IPhase&lt;MyFragment&gt; phase) {
        phases.add(phase);
    }

    override getPhases() {
        return phases;
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">MyPhase</div>
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">class MyPhase implements IPhase&lt;MyFragment&gt;{

    override getOperations(MyFragment fragment) {
        Lists.newArrayList(
                   new AddSecretOperation(),
                   new EncryptStoreOperation(),
                );
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">AddSecretOperation</div>
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">class AddSecretOperation implements IOperation&lt;MyFragment&gt; {

    override execute(MyFragment fragment) {
        fragment.addSecretInformation("My Secret Information");
        return true;
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">EncryptStoreOperation</div>
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">class EncryptStoreOperation implements IOperation&lt;MyFragment&gt; {

    override execute(MyFragment fragment) {
        fragment.encryptStore;
        return true;
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Second step is to build plan and the initializer.</div>
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">class Example {
    def static void main(String[] args) {
        var MyPlan plan = new MyPlan;
        plan.addPhase(new MyPhase());
        plan.addPhase(new MyOtherPhase());

        var MyInitializer initializer = new MyInitializer;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">The last step is to instantiate correct <code>PlanExecutor</code> and call the <code>process</code> method.</div>
<div class="content">
<pre class="highlight"><code class="language-xtend" data-lang="xtend">class Example {
    def static void main(String[] args) {
        var MyPlan plan = new MyPlan;
        plan.addPhase(new MyPhase());
        plan.addPhase(new MyOtherPhase());

        var MyInitializer initializer = new MyInitializer;

        var PlanExecutor&lt;MyFragment, MyInitializer&gt; planExecutor = new PlanExecutor();
        var output = planExecutor.process(plan, initializer);

        output.print;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_live_validation">Live Validation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The VIATRA <a href="addons.html#viatra-validation">Validation Framework</a> offers a declarative approach for defining complex constraints on instance models that are evaluated incrementally during model editing.</p>
</div>
<div class="paragraph">
<p>In the CPS demonstrator we defined a set of constraints for Cyber Physical System instance models in the <code>model/validation/rules.eiq</code> file in the <code>cps.queries</code> project. The constraints include the following examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Host instances must have unique IP addresses</p>
</li>
<li>
<p>The initial state of a state machine must be among the states of the same state machine</p>
</li>
<li>
<p>Transitions must have target states, which must be in the same state machine as the source state</p>
</li>
<li>
<p>Actions of outgoing transitions from a given state must be unique</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_definition_of_constraints">Definition of constraints</h3>
<div class="paragraph">
<p>Each constraint is defined using <code>@Constraint</code> annotations on patterns. The annotation has three required parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <strong>location</strong> identifies which element is the focus of the violation</p>
</li>
<li>
<p>The <strong>message</strong> is a format string that specifies what will be displayed for each violation</p>
</li>
<li>
<p>The <strong>severity</strong> specifies the type of the created marker (error or warning)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>@Constraint(
    location = state,
    message = "Multiple outgoing transitions of $state.id$ define the same action ($action$)",
    severity = "error"
)
pattern multipleTransitionsWithSameAction(state, action) {
    State.outgoingTransitions(state, transition);
    State.outgoingTransitions(state, otherTransition);
    find actionOfTransition(transition, action);
    find actionOfTransition(otherTransition, action);
    transition != otherTransition;
}

private pattern actionOfTransition(transition, action) {
    Transition.action(transition, action);
}</pre>
</div>
</div>
<div class="paragraph">
<p>The VIATRA Query generator fragment generates the required source code and other artefacts automatically when the builder is invoked by saving the query definition file. The code is placed in the <code>cps.queries.validation</code> project.</p>
</div>
</div>
<div class="sect2">
<h3 id="_usage_of_live_validation">Usage of live validation</h3>
<div class="paragraph">
<p>The live validation can be demonstrated in the generated editor for CPS models:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start a Runtime Eclipse</p>
</li>
<li>
<p>Open a CPS instance model (e.g. by importing the <code>cps.instances</code> project) in the generated editor</p>
<div class="ulist">
<ul>
<li>
<p>Right click on a <code>.cyberphysicalsystem</code> file in the <em>Package explorer</em>, <code>Open with &#8594; CyberPhysicalSystem Model Editor</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Initialize the validation</p>
<div class="ulist">
<ul>
<li>
<p>Right click in the tree editor, <code>VIATRA Validation &#8594; Initialize VIATRA Validators on Editor</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Violations of constraints are displayed in the <em>Problems</em> view</p>
<div class="ulist">
<ul>
<li>
<p>Double clicking the violation will set the selection of the editor to the location element</p>
</li>
<li>
<p>Changes in the model will update problem markers immediately</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_incremental_viewers">Incremental Viewers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The VIATRA <a href="addons.html#viewers">Viewers Framework</a> is applied to create custom views for the CPS demonstrator.</p>
</div>
<div class="paragraph">
<p>The views are defined using declarative pattern annotations which specify items and edges in a view. The view may be a graph visualization, but simple UI elements, such as lists or tree views are also supported by the technology. In the CPS demonstrator, we created views using the <a href="https://www.eclipse.org/gef/zest/">Zest</a> Graph Visualization framework.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://git.eclipse.org/c/viatra/org.eclipse.viatra.examples.git/plain/cps/models/org.eclipse.viatra.examples.cps.instances/deployment_viewer.png" alt="Deployment model viewer">
</div>
</div>
<div class="paragraph">
<p>The definition of the views can be found in the <code>cps.queries</code> project in the <code>model/viewer</code> and <code>deployment/viewer</code> packages. Items are defined with <code>@Item</code> annotations, edges are specified with <code>@Edge</code> annotations, while the format (such as colours) is described with <code>@Format</code> annotations.</p>
</div>
<div class="sect2">
<h3 id="_viewer_example">Viewer example</h3>
<div class="paragraph">
<p>The following patterns define the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create items for each deployment host</p>
</li>
<li>
<p>Create items for each deployment application</p>
</li>
<li>
<p>Create edges between items that correspond to the deployment host and application objects</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>@Format(color = "#FBFE00")
@Item(item = host, label = "Host $host.ip$")
pattern deploymentHostItem(host) {
    DeploymentHost(host);
}

@Format(color = "#996600")
@Item(item = app, label = "App $app.id$")
pattern deploymentApplicationItem(app) {
    DeploymentApplication(app);
}

@Edge(source = host, target = app, label = "apps")
pattern deploymentHostApplicationEdge(host, app) {
    DeploymentHost.applications(host, app);
}</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cps_application">CPS Application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The CPS Demonstrator application include various features to demonstrate various capabilities of VIATRA using the <a href="#_domains">CPS domain models</a>.</p>
</div>
<div class="sect2">
<h3 id="_how_to_start">How to start</h3>
<div class="paragraph">
<p>Start the CPS Application Eclipse instance (<a href="https://download.eclipse.org/viatra/examples/cps/application/">download from here</a>).</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Starting multiple instances of this application causes <code>Java was started but returned exit code=1</code> error message caused by both applications opening port 1099 for the VIATRA debugger to connect to.  In order to support multiple instances, you have to <a href="../extra/VIATRA-debugger.html#_setting_up_the_transformation_under_debugging">modify the debug port number</a> in the corresponding eclipse.ini file.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_initializing_cps_models">Initializing CPS models</h3>
<div class="paragraph">
<p>Select <em>File/New/Other</em> and in the <em>CPS Demonstrator</em> category select <em>CPS Demonstrator Example</em> and create an example project.<br>
This project contains an example CPS model <em>(example.cyberphysicalsystem)</em> as the source model of the transformation, an empty target model <em>(example.deployment)</em> and an <em>example.traceability</em>, which connects the source and target models.</p>
</div>
</div>
<div class="sect2">
<h3 id="_executing_the_transformation">Executing the transformation</h3>
<div class="paragraph">
<p>The CPS Transformations view allows starting or stopping <a href="#_cps_to_deployment_transformation">CPS-to-Deployment M2M transformations</a> using <a href="#_transformation_implementations">different strategies</a> and displays the running transformations.<br>
To open the view press CTRL+3 and type the name of the view.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/cps/cps_transform_view.png" alt="CPS Transformations view">
</div>
</div>
<div class="paragraph">
<p>The view shows the details of the currently running transformations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the name of the resource which contains the model</p>
</li>
<li>
<p>the transformation strategy</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Double-click on a transformation to navigate to the model.</p>
</div>
<div class="paragraph">
<p><strong>Transformation strategies:</strong><br>
In a drop-down list you can select a <a href="#Transformation implementations">strategy</a> for the transformation.
There are two execution modes batch and incremental.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The batch mode clears the destination model and transforms the whole source model then stops.</p>
</li>
<li>
<p>The incremental transformations transform the model, then continue to run and apply changes of the source model to the destination model.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Operations:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Run Transformation <span class="image"><img src="./images/cps/load_query_icon.png" alt="load query icon"></span> : Open the Traceability model and select a <code>CPS To Deployment</code> element. This button starts a new transformation with the selected strategy.</p>
</li>
<li>
<p>Run Transformation with Debugger <span class="image"><img src="./images/cps/load_xform_w_debugger_icon.png" alt="load xform w debugger icon"></span> : This button starts a new transformation on a <code>CPS To Deployment</code> element with the selected strategy. The transformation does not start until a <a href="#debug">VIATRA Transformation Remote Debugging</a> is connected.</p>
</li>
<li>
<p>Stop Transformation <span class="image"><img src="./images/xcps/unload_icon.gif" alt="unload icon"></span> : Stops a currently running incremental transformation (selected below) and releases its resources.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_advanced">Advanced</h3>
<div class="sect3">
<h4 id="debug">Using the Transformation Debugger</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Select a <code>CPS To Deployment</code> element and start a VIATRA transformation with debugger support. Now the transformation is waiting for a debugger to be attached.</p>
</li>
<li>
<p>Open Debug perspective</p>
</li>
<li>
<p>In <em>Run/Debug Configurations</em> create a new VIATRA Transformations Remote Debugging</p>
</li>
<li>
<p>Set the Target Port to 10990 and press <em>Query Port</em>, then the transformation appears in the Target VIATRA Transformation list</p>
</li>
<li>
<p>The Java class which defines the transformation should be entered into the VIATRA Transformation Class field to associate the breakpoints with it. This time use a new dummy class in a new Java project.</p>
</li>
<li>
<p>Press Debug</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Use Step Over, set breakpoints and Resume the transformation.<br>
The following views help the debugging:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Transformation Browser view shows which activation of the transformation rules can be executed. Here you can set breakpoints to suspend if a certain rule or activation is to be executed or a condition is true.</p>
</li>
<li>
<p>Transformation Model Instance Viewer shows the current state of the models during the transformation.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/cps/cps_debug.png" alt="CPS Debug Configuration">
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Using the same Eclipse instance for debugging an incremental transformation and changing a model causes the program to freeze. Use a different Eclipse instance or run a new Eclipse Application instance from <em>Run/Run Configurations</em> and run the debugger from it.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Find more details on the debugger <a href="transformations.html#transformation-debugger">here</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_cps_model_generator_wizard">CPS Model Generator wizard</h4>
<div class="paragraph">
<p>In addition of initializing a prepared example or manually creating the CPS models, the demonstrator also includes a CPS Model Generator, which can create instances of predefined models and also supports generating arbitrarily large CPS models.</p>
</div>
<div class="paragraph">
<p>Select <em>File/New/Other</em> and in the <em>CPS Demonstrator</em> category select <em>Generate CPS Model</em>. Select a folder and enter a name for the CPS model.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In contrast to <em>CPS Demonstrator Example</em> project, which generates a source CPS model, a target Deployment model and a connector Traceability model, the CPS Model Generator only generates the CPS model, which must be connected to the other models to use it in a transformation. To do this manually refer <a href="#init-models-manual">this section</a>.
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/cps/cps_wizard_type_page.png" alt="Types of Models in CPS Model Generator">
</div>
</div>
<div class="paragraph">
<p>To create a simple model you can choose from a few preset models under the <em>Simple Test Models</em> option.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Some generators use random numbers. The initial value of the seed is time-dependent, so models are very likely to be distinct on each generation. To produce the same models use the same arbitrary number as random seed each time.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_scalable_models">Scalable Models</h5>
<div class="paragraph">
<p>To create arbitrarily large CPS models, which are similar in structure, but have different number of elements, choose a <em>Scalable Model</em> type. Enter a positive a scaling factor, which is proportional to the number of model elements. To generate a model with reasonable size which can be opened in the editor enter a scaling factor from the recommended range.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Opening large models can take a while. Switch off opening if it is not needed.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_model_by_detailed_constraints">Model by Detailed Constraints</h5>
<div class="imageblock">
<div class="content">
<img src="./images/cps/cps_wizard_details_page.png" alt="Detailed Model Generator Constraints">
</div>
</div>
<div class="paragraph">
<p>CPS Model Generator uses a detailed configuration during generation phase. (&lt;&lt;Model-Generator#,Here&gt; described in detail.) A simple version of this configuration can be used if you select Model by Detailed Constraints.</p>
</div>
<div class="paragraph">
<p>Some of the parameters are specified with a min-max range, which is used to obtain a random number of the range to get the exact value of that parameter.<br>
Other parameters are percentage parameters, which is used to decide how to distribute the choices for the possible elements.</p>
</div>
<div class="paragraph">
<p>For the Hosts you can define how many HostTypes and how many HostInstances for each type exist. For each instance the number of communication lines will fall into the defined range.
The number of generated signals can be specified too.<br>
The number of ApplicationTypes and ApplicationInstances can be defined similarly. Also the number of states and transitions in the statemachine of an ApplicationInstance can be defined. The ratio how many ApplicationInstances are allocated to a HostInstance, the ratio of actions in the transitions and the ratio of send action in all the actions can be specified with percentage parameters.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="init-models-manual">Initializing CPS models manually</h4>
<div class="ulist">
<ul>
<li>
<p>Create a <em>Deployment Model</em> (<em>File/New/Other</em> and <em>CPS Demonstrator</em> category)</p>
<div class="ulist">
<ul>
<li>
<p>Root element shall be <em>Deployment</em></p>
</li>
</ul>
</div>
</li>
<li>
<p>Create a <em>Traceability Model</em> (<em>File/New/Other</em> and <em>CPS Demonstrator</em> category)</p>
<div class="ulist">
<ul>
<li>
<p>Root element shall be <em>CPS To Deployment</em></p>
</li>
</ul>
</div>
</li>
<li>
<p>Open the Traceability file</p>
</li>
<li>
<p>In the Traceability editor, load both the existing CPS and the newly created Deployment models with <em>Load Resources...</em> in the context menu</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/viatraIncr_example4.png" alt="Load necessary resources into the Tracebility Model">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Set CPS and Deployment references of Traceability model in the properties view</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/tutorial/viatraIncr_example5.png" alt="Set the references of the Traceability Model">
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>